<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>响应式原理</title>
      <link href="/2021/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/"/>
      <url>/2021/12/13/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="Vue响应式原理"><a href="#Vue响应式原理" class="headerlink" title="Vue响应式原理"></a>Vue响应式原理</h3><h4 id="响应式介绍"><a href="#响应式介绍" class="headerlink" title="响应式介绍"></a>响应式介绍</h4><h4 id="响应式手写"><a href="#响应式手写" class="headerlink" title="响应式手写"></a>响应式手写</h4>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN 的原理</title>
      <link href="/2021/11/15/CDN-%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2021/11/15/CDN-%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h4 id="CDN的介绍及原理"><a href="#CDN的介绍及原理" class="headerlink" title="CDN的介绍及原理"></a>CDN的介绍及原理</h4><h5 id="一、什么是CDN"><a href="#一、什么是CDN" class="headerlink" title="一、什么是CDN"></a>一、什么是CDN</h5><p>​    CDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。</p><p>​    上述片段是百度百科中对CDN的介绍，简单理解CDN就是在虚拟网络上，依靠部署在各地的服务器，当用户获取时，通过功能模块使用户就近获取到数据。</p><h5 id="二、CDN的原理"><a href="#二、CDN的原理" class="headerlink" title="二、CDN的原理"></a>二、CDN的原理</h5><p>​    CDN就是在用户和服务器之间添加了一个Cache层，当用户访问存放在CDN上的资源时，将用户的请求引导到CDN上获取源服务器存放在CDN上的数据，从而达到提高响应速度，解决用户访问量过大等问题。</p><p>​    当用户访问CDN上的资源时，首先会对域名进行一个DNS解析，解析过程中会发现已经配置了CNAME，会向CNAME域名发送请求，然后依靠CDN内部的功能模块会分配最佳节点IP，然后用户依据获取到的IP发送对资源的请求，若该IP节点中缓存了所需的资源，则直接返回，否则会向业务源站发出资源的请求，获取资源后返回给用户，同时在节点处依据用户的存储策略将资源存储在IP节点出。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS中call_apply_bind的实现</title>
      <link href="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="Call、Apply、Bind的手写实现"><a href="#Call、Apply、Bind的手写实现" class="headerlink" title="Call、Apply、Bind的手写实现"></a>Call、Apply、Bind的手写实现</h3><p>​        每个函数在创建时都会自带一些函数，其中call、apply、bind这几个函数是面试中经常会问到的函数，今天来手写这几个函数。</p><h4 id="一、call的手写实现"><a href="#一、call的手写实现" class="headerlink" title="一、call的手写实现"></a>一、call的手写实现</h4><h5 id="call的简单介绍"><a href="#call的简单介绍" class="headerlink" title="call的简单介绍"></a>call的简单介绍</h5><p>​        函数在调用 call 函数时，可以传入多个参数，第一个参数作为函数调用时其中的this绑定对象，后面的参数都为函数执行时传入的参数。简单看一下基础的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br>add.call(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>该函数的输出结果为：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211106000153018.png" alt="image-20211106000153018"></p><p>​        当第一个参数传入的为 number || string 类型时，会自动将其变为Number | String 对象类型， 传入的值为 null 或者未传入时，会将 this 绑定在 Windows上。</p><h5 id="call手写实现"><a href="#call手写实现" class="headerlink" title="call手写实现"></a>call手写实现</h5><p>​        先理解一下 this 的绑定规则，再通过对象来调用某个函数时，this会默认绑定为该对象。这里利用这个思路，可以在传入的第一个参数的对象上创建一个属性，并将其的属性值绑定为该函数，然后利用该对象来执行函数，并将剩下的参数作为函数参数传入即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...argArray</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray)<br>  <span class="hljs-keyword">delete</span> thisArg.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>​        对传入的第一个参数进行一个判断，判断是否是 null 或者 undefined，如果是则将对象绑定为 Windows，否则利用 Object 方法将第一个参数变为对应的对象。</p><p>​        其中第二个参数是 es6 中，获取函数剩余参数的方法，这里就不多赘述了。</p><p>在通过传入的 this 调用该函数时将其解构传入即可。</p><p>​        最后别忘将对象上的 fn 函数删除即可。可能有的小伙伴会问：如果传入的对象上已经有了 fn 对象怎么办？我们其实有很多的解决方法，大家可以自行考虑一下，我这里就不对其进行一个判断了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br>add.myCall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>​        函数的输出:</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211106001219131.png" alt="image-20211106001219131"></p><h4 id="二、-apply的手写实现"><a href="#二、-apply的手写实现" class="headerlink" title="二、 apply的手写实现"></a>二、 apply的手写实现</h4><h5 id="apply的简单介绍"><a href="#apply的简单介绍" class="headerlink" title="apply的简单介绍"></a>apply的简单介绍</h5><p>​    apply函数与call函数比较相似，唯一的不同点是 bind 的第二个参数是一个数组，里面执行函数的参数。其他规则和call相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br>add.apply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>​        执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234201133.png" alt="image-20211108234201133"></p><h5 id="apply的手写实现"><a href="#apply的手写实现" class="headerlink" title="apply的手写实现"></a>apply的手写实现</h5><p>​    在call的基础上进行一定的修改即可，将第二个参数改为数组即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, argArray = []</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray)<br>  <span class="hljs-keyword">delete</span> thisArg.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>​        另外要注意一点的是，apply第二个参数是可以不传的，call中之所以可以不用给默认值，是因为在ES6中获取剩余参数的写法包括了不传时的情况的。而apply这里则需要给第二个参数一个默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br>add.myApply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>​        函数的输出：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234304879.png" alt="image-20211108234304879"></p><h4 id="三、bind的手写实现"><a href="#三、bind的手写实现" class="headerlink" title="三、bind的手写实现"></a>三、bind的手写实现</h4><h5 id="bind的简单介绍"><a href="#bind的简单介绍" class="headerlink" title="bind的简单介绍"></a>bind的简单介绍</h5><p>​        bind的函数可以传入多个参数，第一个参数代表所要绑定的this对象，可传入多个参数也可传入一个参数，剩余参数则作为函数执行时的参数，与call和apply不同的是，bind会返回一个绑定了this对象的函数，且在调用该函数时也可以传入参数也可以不传入参数，传入参数的话会与调用bind函数时传入的剩余参数一起作为函数的参数执行。</p><p>​        简单看一下bind的使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br><span class="hljs-keyword">const</span> add2 = add.bind(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;,<span class="hljs-number">10</span>)<br>add2(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>​        上面函数的执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108233740541.png" alt="image-20211108233740541"></p><p>​        且当第一个参数传入的为 number || string 类型时，也会自动将其变为Number | String 对象类型， 传入的值为 null 或者未传入时，会将 this 绑定在 Windows上。</p><h5 id="bind的手写实现"><a href="#bind的手写实现" class="headerlink" title="bind的手写实现"></a>bind的手写实现</h5><p>​        调用bind后所返回的是一个函数，我们可以在call和apply的实现基础上进行一定的改变，利用闭包的概念，在返回的函数中调用函数，且对传入的参数进行一个拼接即可达到效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...argArray</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray, ...arg)<br>    <span class="hljs-keyword">delete</span> thisArg.fn<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><span class="hljs-keyword">const</span> add2 = add.myBind(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;,<span class="hljs-number">10</span>)<br>add2(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>​        执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234618529.png" alt="image-20211108234618529"></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>​        最后如果上面的代码存在问题或者存在某些BUG，大家可以私聊我，我会在第一时间改正，一位正在努力学习前端的小白，欢迎大家的提论和评论，后面如果有什么补充的也会第一时间补充上去的。</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客的创建</title>
      <link href="/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
      <url>/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h4 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h4><p>​                很久以前就想做一个属于自己的博客了,可以一直没有机会,直到最近才正式开始了博客的创建。找了很多个博客的工具,最后选择了hexo来创建.创建过程也是坎坎坷坷.</p><h5 id="一、Hexo的安装前的准备"><a href="#一、Hexo的安装前的准备" class="headerlink" title="一、Hexo的安装前的准备"></a>一、Hexo的安装前的准备</h5><p>​    下载Hexo需要先下载好Node.js 和 Git，已经下载过了的小伙伴可以跳过这一部分, 如果还未下载过可以先下载Node.js，尽量选择高版本, 不容易出现问题。</p><p><a href="http://nodejs.cn/">Node官网</a> </p><p>下载以后可以通过在命令行输入：node -v 可以查看是否成功安装</p><p>​    <img src="/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/image-20211030162920922.png" alt="image-20211030162920922"></p><p>​    如果出现以上字符,恭喜你安装成功啦！接下来进行 Git 的安装了，也尽量选择高版本的Git。</p><p><a href="https://git-scm.com/">Git官网</a> </p><p>​    安装成功后，鼠标右键会出现 GIT GUI 和 GIT BUSH 选项，出现了说明安装成功啦!</p><h5 id="二、Hexo的安装"><a href="#二、Hexo的安装" class="headerlink" title="二、Hexo的安装"></a>二、Hexo的安装</h5><p>​    安装完Node 和 Git 后就可以开始 Hexo的安装了，下面附上Hexo的官网地址，有需要的小伙伴可以进入。</p><p>​    <a href="https://hexo.io/zh-cn/">Hexo官网</a></p><p>​    打开CMD执行以下命令即可全局安装 Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo -g<br></code></pre></td></tr></table></figure><p>​    安装完成后进入想创建博客的文件夹下，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>​    第一次初始化时间比较久，耐心等待一下。初始化完成后安装一下依赖即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install<br></code></pre></td></tr></table></figure><p>完成以上操作，Hexo安装算是安装完成了。可以使用了！</p><h5 id="三、Hexo的使用"><a href="#三、Hexo的使用" class="headerlink" title="三、Hexo的使用"></a>三、Hexo的使用</h5><p>​    创建一篇新的文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;文章名&quot;<br></code></pre></td></tr></table></figure><p>​    回车即可，在source文件夹下找到该 md 文件，进行编写即可。编写完成后使用一下命令，即可自动生成文件，启动本地服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo clean<br>hexo serve<br></code></pre></td></tr></table></figure><p>​    使用浏览器访问 localhost:4000 即可查看到博客啦！</p>]]></content>
      
      
      <categories>
          
          <category> live </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第一个博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
