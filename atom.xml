<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>coderShy</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-11-08T16:01:19.801Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JS中call_apply_bind的实现</title>
    <link href="http://example.com/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2021-11-05T15:53:12.000Z</published>
    <updated>2021-11-08T16:01:19.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Call、Apply、Bind的手写实现"><a href="#Call、Apply、Bind的手写实现" class="headerlink" title="Call、Apply、Bind的手写实现"></a>Call、Apply、Bind的手写实现</h3><p>​        每个函数在创建时都会自带一些函数，其中call、apply、bind这几个函数是面试中经常会问到的函数，今天来手写这几个函数。</p><h4 id="一、call的手写实现"><a href="#一、call的手写实现" class="headerlink" title="一、call的手写实现"></a>一、call的手写实现</h4><h5 id="call的简单介绍"><a href="#call的简单介绍" class="headerlink" title="call的简单介绍"></a>call的简单介绍</h5><p>​        函数在调用 call 函数时，可以传入多个参数，第一个参数作为函数调用时其中的this绑定对象，后面的参数都为函数执行时传入的参数。简单看一下基础的使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br>add.call(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>该函数的输出结果为：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211106000153018.png" alt="image-20211106000153018"></p><p>​        当第一个参数传入的为 number || string 类型时，会自动将其变为Number | String 对象类型， 传入的值为 null 或者未传入时，会将 this 绑定在 Windows上。</p><h5 id="call手写实现"><a href="#call手写实现" class="headerlink" title="call手写实现"></a>call手写实现</h5><p>​        先理解一下 this 的绑定规则，再通过对象来调用某个函数时，this会默认绑定为该对象。这里利用这个思路，可以在传入的第一个参数的对象上创建一个属性，并将其的属性值绑定为该函数，然后利用该对象来执行函数，并将剩下的参数作为函数参数传入即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...argArray</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray)<br>  <span class="hljs-keyword">delete</span> thisArg.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>​        对传入的第一个参数进行一个判断，判断是否是 null 或者 undefined，如果是则将对象绑定为 Windows，否则利用 Object 方法将第一个参数变为对应的对象。</p><p>​        其中第二个参数是 es6 中，获取函数剩余参数的方法，这里就不多赘述了。</p><p>在通过传入的 this 调用该函数时将其解构传入即可。</p><p>​        最后别忘将对象上的 fn 函数删除即可。可能有的小伙伴会问：如果传入的对象上已经有了 fn 对象怎么办？我们其实有很多的解决方法，大家可以自行考虑一下，我这里就不对其进行一个判断了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br>add.myCall(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;1&#x27;</span>&#125;, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>​        函数的输出:</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211106001219131.png" alt="image-20211106001219131"></p><h4 id="二、-apply的手写实现"><a href="#二、-apply的手写实现" class="headerlink" title="二、 apply的手写实现"></a>二、 apply的手写实现</h4><h5 id="apply的简单介绍"><a href="#apply的简单介绍" class="headerlink" title="apply的简单介绍"></a>apply的简单介绍</h5><p>​    apply函数与call函数比较相似，唯一的不同点是 bind 的第二个参数是一个数组，里面执行函数的参数。其他规则和call相同。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br>add.apply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>​        执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234201133.png" alt="image-20211108234201133"></p><h5 id="apply的手写实现"><a href="#apply的手写实现" class="headerlink" title="apply的手写实现"></a>apply的手写实现</h5><p>​    在call的基础上进行一定的修改即可，将第二个参数改为数组即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, argArray = []</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray)<br>  <span class="hljs-keyword">delete</span> thisArg.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>​        另外要注意一点的是，apply第二个参数是可以不传的，call中之所以可以不用给默认值，是因为在ES6中获取剩余参数的写法包括了不传时的情况的。而apply这里则需要给第二个参数一个默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br>add.myApply(&#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;123&#x27;</span>&#125;, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br></code></pre></td></tr></table></figure><p>​        函数的输出：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234304879.png" alt="image-20211108234304879"></p><h4 id="三、bind的手写实现"><a href="#三、bind的手写实现" class="headerlink" title="三、bind的手写实现"></a>三、bind的手写实现</h4><h5 id="bind的简单介绍"><a href="#bind的简单介绍" class="headerlink" title="bind的简单介绍"></a>bind的简单介绍</h5><p>​        bind的函数可以传入多个参数，第一个参数代表所要绑定的this对象，可传入多个参数也可传入一个参数，剩余参数则作为函数执行时的参数，与call和apply不同的是，bind会返回一个绑定了this对象的函数，且在调用该函数时也可以传入参数也可以不传入参数，传入参数的话会与调用bind函数时传入的剩余参数一起作为函数的参数执行。</p><p>​        简单看一下bind的使用方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><br><span class="hljs-keyword">const</span> add2 = add.bind(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;,<span class="hljs-number">10</span>)<br>add2(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>​        上面函数的执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108233740541.png" alt="image-20211108233740541"></p><p>​        且当第一个参数传入的为 number || string 类型时，也会自动将其变为Number | String 对象类型， 传入的值为 null 或者未传入时，会将 this 绑定在 Windows上。</p><h5 id="bind的手写实现"><a href="#bind的手写实现" class="headerlink" title="bind的手写实现"></a>bind的手写实现</h5><p>​        调用bind后所返回的是一个函数，我们可以在call和apply的实现基础上进行一定的改变，利用闭包的概念，在返回的函数中调用函数，且对传入的参数进行一个拼接即可达到效果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg, ...argArray</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">this</span><br>  thisArg = (thisArg !== <span class="hljs-literal">undefined</span> &amp;&amp; thisArg !== <span class="hljs-literal">null</span>) ? <span class="hljs-built_in">Object</span>(thisArg) : <span class="hljs-built_in">window</span><br>  thisArg.fn = fn<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> result = thisArg.fn(...argArray, ...arg)<br>    <span class="hljs-keyword">delete</span> thisArg.fn<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>)<br>  <span class="hljs-built_in">console</span>.log(num1 + num2)<br>&#125;<br><span class="hljs-keyword">const</span> add2 = add.myBind(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;123&#x27;</span>&#125;,<span class="hljs-number">10</span>)<br>add2(<span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p>​        执行结果：</p><p><img src="/2021/11/05/JS%E4%B8%ADcall-apply-bind%E7%9A%84%E5%AE%9E%E7%8E%B0/image-20211108234618529.png" alt="image-20211108234618529"></p><h4 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h4><p>​        最后如果上面的代码存在问题或者存在某些BUG，大家可以私聊我，我会在第一时间改正，一位正在努力学习前端的小白，欢迎大家的提论和评论，后面如果有什么补充的也会第一时间补充上去的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Call、Apply、Bind的手写实现&quot;&gt;&lt;a href=&quot;#Call、Apply、Bind的手写实现&quot; class=&quot;headerlink&quot; title=&quot;Call、Apply、Bind的手写实现&quot;&gt;&lt;/a&gt;Call、Apply、Bind的手写实现&lt;/h3&gt;&lt;</summary>
      
    
    
    
    <category term="js" scheme="http://example.com/categories/js/"/>
    
    
    <category term="js 面试" scheme="http://example.com/tags/js-%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>博客的创建</title>
    <link href="http://example.com/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <id>http://example.com/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/</id>
    <published>2021-10-29T05:34:38.000Z</published>
    <updated>2021-11-08T16:00:17.361Z</updated>
    
    <content type="html"><![CDATA[<h4 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h4><p>​                很久以前就想做一个属于自己的博客了,可以一直没有机会,直到最近才正式开始了博客的创建。找了很多个博客的工具,最后选择了hexo来创建.创建过程也是坎坎坷坷.</p><h5 id="一、Hexo的安装前的准备"><a href="#一、Hexo的安装前的准备" class="headerlink" title="一、Hexo的安装前的准备"></a>一、Hexo的安装前的准备</h5><p>​    下载Hexo需要先下载好Node.js 和 Git，已经下载过了的小伙伴可以跳过这一部分, 如果还未下载过可以先下载Node.js，尽量选择高版本, 不容易出现问题。</p><p><a href="http://nodejs.cn/">Node官网</a> </p><p>下载以后可以通过在命令行输入：node -v 可以查看是否成功安装</p><p>​    <img src="/2021/10/29/%E5%8D%9A%E5%AE%A2%E7%9A%84%E5%88%9B%E5%BB%BA/image-20211030162920922.png" alt="image-20211030162920922"></p><p>​    如果出现以上字符,恭喜你安装成功啦！接下来进行 Git 的安装了，也尽量选择高版本的Git。</p><p><a href="https://git-scm.com/">Git官网</a> </p><p>​    安装成功后，鼠标右键会出现 GIT GUI 和 GIT BUSH 选项，出现了说明安装成功啦!</p><h5 id="二、Hexo的安装"><a href="#二、Hexo的安装" class="headerlink" title="二、Hexo的安装"></a>二、Hexo的安装</h5><p>​    安装完Node 和 Git 后就可以开始 Hexo的安装了，下面附上Hexo的官网地址，有需要的小伙伴可以进入。</p><p>​    <a href="https://hexo.io/zh-cn/">Hexo官网</a></p><p>​    打开CMD执行以下命令即可全局安装 Hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install hexo -g<br></code></pre></td></tr></table></figure><p>​    安装完成后进入想创建博客的文件夹下，执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo init<br></code></pre></td></tr></table></figure><p>​    第一次初始化时间比较久，耐心等待一下。初始化完成后安装一下依赖即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npm install<br></code></pre></td></tr></table></figure><p>完成以上操作，Hexo安装算是安装完成了。可以使用了！</p><h5 id="三、Hexo的使用"><a href="#三、Hexo的使用" class="headerlink" title="三、Hexo的使用"></a>三、Hexo的使用</h5><p>​    创建一篇新的文章</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo new &quot;文章名&quot;<br></code></pre></td></tr></table></figure><p>​    回车即可，在source文件夹下找到该 md 文件，进行编写即可。编写完成后使用一下命令，即可自动生成文件，启动本地服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">hexo g<br>hexo clean<br>hexo serve<br></code></pre></td></tr></table></figure><p>​    使用浏览器访问 localhost:4000 即可查看到博客啦！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;博客的创建&quot;&gt;&lt;a href=&quot;#博客的创建&quot; class=&quot;headerlink&quot; title=&quot;博客的创建&quot;&gt;&lt;/a&gt;博客的创建&lt;/h4&gt;&lt;p&gt;​                很久以前就想做一个属于自己的博客了,可以一直没有机会,直到最近才正式开始了博客的创</summary>
      
    
    
    
    <category term="live" scheme="http://example.com/categories/live/"/>
    
    
    <category term="第一个博客" scheme="http://example.com/tags/%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
</feed>
